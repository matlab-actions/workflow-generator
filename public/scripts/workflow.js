function parseRepositoryURL(repoURL) {
  repoURL = repoURL.trim().replace(/\.git$/i, "");

  // SSH and git protocol (e.g., git@github.com:owner/repo or git://host/owner/repo)
  const m = repoURL.match(
    /^(git@|ssh:\/\/git@|git:\/\/)([^:/]+)[:/]((?:[^/]+\/)+[^/]+)$/i,
  );
  if (m) {
    const host = m[2];
    const parts = m[3].split("/").filter(Boolean);
    // GitHub Enterprise SSH URL: git@github.com:enterprises/enterprise/owner/repo
    if (
      host.toLowerCase() === "github.com" &&
      parts[0] === "enterprises" &&
      parts.length >= 4
    ) {
      return {
        origin: `https://github.com`,
        enterprise: parts[1],
        owner: parts[2],
        repo: parts[3],
      };
    } else if (parts.length === 2) {
      // Standard SSH URL: git@host:owner/repo
      return {
        origin: `https://${host}`,
        owner: parts[0],
        repo: parts[1],
      };
    }
    // Unrecognized SSH format
    return null;
  }

  // Shorthand and domain/owner/repo (e.g., owner/repo or host/owner/repo)
  if (!/^\w+:\/\//.test(repoURL)) {
    const parts = repoURL.split("/").filter(Boolean);
    if (parts.length === 2) {
      // owner/repo shorthand (assume github.com)
      return {
        origin: "https://github.com",
        owner: parts[0],
        repo: parts[1],
      };
    } else if (parts.length >= 3 && parts[0].includes(".")) {
      // treat as URL, fall through to URL parsing
      repoURL = "https://" + repoURL;
    } else {
      // Unrecognized shorthand
      return null;
    }
  }

  // HTTP(S) URLs (e.g., https://github.com/owner/repo)
  try {
    const url = new URL(repoURL);
    const parts = url.pathname.split("/").filter(Boolean);
    // GitHub Enterprise HTTP URL: https://github.com/enterprises/enterprise/owner/repo
    if (
      url.host.toLowerCase() === "github.com" &&
      parts[0] === "enterprises" &&
      parts.length >= 4
    ) {
      return {
        origin: url.origin,
        enterprise: parts[1],
        owner: parts[2],
        repo: parts[3],
      };
    } else if (parts.length >= 2) {
      // Standard HTTP(S) URL: https://host/owner/repo
      return {
        origin: url.origin,
        owner: parts[0],
        repo: parts[1],
      };
    }
  } catch {
    // Not a valid URL, fall through
  }

  // If none of the above matched, return null
  return null;
}

function generateWorkflow({
  useBatchToken = false,
  useVirtualDisplay = false,
  buildAcrossPlatforms = false,
  siteUrl = "http://localhost/",
  jsyaml,
}) {
  const yamlObject = {
    name: "MATLAB",
    on: {
      push: {
        branches: ["main"],
      },
      pull_request: {
        branches: ["main"],
      },
      workflow_dispatch: {},
    },
    ...(useBatchToken && {
      env: {
        MLM_LICENSE_TOKEN: "${{ secrets.MLM_LICENSE_TOKEN }}",
      },
    }),
    jobs: {
      build: {
        ...(buildAcrossPlatforms
          ? {
              strategy: {
                "fail-fast": false,
                matrix: {
                  os: ["ubuntu-latest", "windows-latest", "macos-latest"],
                },
              },
              "runs-on": "${{ matrix.os }}",
            }
          : {
              "runs-on": "ubuntu-latest",
            }),
        steps: [
          {
            uses: "actions/checkout@v4",
          },
          ...(useVirtualDisplay
            ? [
                {
                  name: "Start virtual display server",
                  if: "runner.os == 'Linux'",
                  run: [
                    "sudo apt-get install -y xvfb",
                    "Xvfb :99 &",
                    'echo "DISPLAY=:99" >> $GITHUB_ENV',
                  ].join("\n"),
                },
              ]
            : []),
          {
            name: "Set up MATLAB",
            uses: "matlab-actions/setup-matlab@v2",
            with: {
              release: "latest",
              products:
                "Simulink Deep_Learning_Toolbox Computer_Vision_Toolbox",
              cache: "true",
            },
          },
          {
            name: "Run MATLAB tests",
            uses: "matlab-actions/run-tests@v2",
          },
        ],
      },
    },
  };

  let yaml = jsyaml.dump(yamlObject, {
    lineWidth: -1,
    noCompatMode: true,
  });
  yaml =
    `# This workflow was generated by ${siteUrl}\n\n` +
    yaml
      .replace(
        /^(\s*)products:/m,
        "$1# Products to set up in addition to MATLAB\n" +
          "$1# See https://github.com/matlab-actions/setup-matlab/?tab=readme-ov-file#set-up-matlab\n" +
          "$1# products:",
      ) // comment out products and add comment above
      .replace(
        /^(\s*)(MLM_LICENSE_TOKEN: .*)/m,
        "$1# You must set the MLM_LICENSE_TOKEN secret in your repository settings\n" +
          "$1# See https://github.com/matlab-actions/setup-matlab/?tab=readme-ov-file#use-matlab-batch-licensing-token\n" +
          "$1$2",
      ) // comment above MLM_LICENSE_TOKEN
      .replace(/^'on':/m, "on:") // unquote 'on'
      .replace(/'true'/g, "true") // unquote 'true'
      .replace(/branches:\n\s*-\s*(\w+)/g, "branches: [$1]") // inline branches
      .replace(
        /os:\n\s*-\s*(\S+)\n\s*-\s*(\S+)\n\s*-\s*(\S+)/,
        "os: [$1, $2, $3]",
      ) // inline os matrix
      .replace(/^(on:)/m, "\n$1") // blank before 'on:'
      .replace(/^(env:)/m, "\n$1") // blank before 'env:'
      .replace(/^(jobs:)/m, "\n$1") // blank before 'jobs:'
      .replace(/^(\s*)steps:/gm, "\n$1steps:") // blank before 'steps:'
      .replace(/^(\s*)- name:/gm, "\n$1- name:"); // blank before '- name:'

  return yaml;
}

export { parseRepositoryURL, generateWorkflow };
